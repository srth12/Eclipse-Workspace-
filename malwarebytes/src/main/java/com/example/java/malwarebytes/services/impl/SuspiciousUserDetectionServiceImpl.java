package com.example.java.malwarebytes.services.impl;

import com.example.java.malwarebytes.dao.UserRequestDAO;
import com.example.java.malwarebytes.dto.*;
import com.example.java.malwarebytes.services.Distance;
import com.example.java.malwarebytes.services.IPGeoLocationService;
import com.example.java.malwarebytes.services.SuspiciousUserDetectinService;
import com.maxmind.geoip2.exception.GeoIp2Exception;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.net.URISyntaxException;
import java.util.List;
import java.util.Optional;

@Component
public class SuspiciousUserDetectionServiceImpl implements SuspiciousUserDetectinService {

    private static final int THRESHOLD_VELOCITY = 500;

    @Autowired
    private IPGeoLocationService ipGeoLocationService;

    @Autowired
    private UserService userService;

    /**
     * Check and return the suspicious login details
     * @param userRequest
     * @return
     * @throws GeoIp2Exception
     * @throws IOException
     * @throws URISyntaxException
     */
    public UserResponse checkSuspiciousLoginAttempts(UserRequest userRequest) throws GeoIp2Exception, IOException, URISyntaxException {
        GeoLocation geoLocation = null;
        try {
            geoLocation = ipGeoLocationService.getGeoLocation(userRequest.getIpAddress());
            UserRequestDAO userDetails = UserRequestDAO.builder().userId(userRequest.getUserName())
                    .ip(userRequest.getIpAddress()).latitude(geoLocation.getLatitude())
                    .longitude(geoLocation.getLongitude()).radius(geoLocation.getRadius())
                    .loginRequestId(userRequest.getLoginRequestId())
                    .timestamp(userRequest.getEventTS()).build();
            userService.saveOrUpdate(userDetails);

            return createResponse(userRequest, geoLocation);
        } catch (Exception e){
            e.printStackTrace();
            throw e;
        }
    }

    /**
     * Creates the response necessary for the 'checkSuspiciousLoginAttempts' method
     * @param userRequest
     * @param geoLocation
     * @return
     */
    public UserResponse createResponse(UserRequest userRequest, GeoLocation geoLocation) {
        Optional<PrecedingIpAccess> previousGeoLocation = getPreviousGeoLocation(userRequest, geoLocation);
        Optional<SubsequentIpAccess> subsequentGeoLocation = getSubsequentGeoLocation(userRequest, geoLocation);

        UserResponse.UserResponseBuilder userResponseBuilder = UserResponse.builder()
                .currentGeo(geoLocation)
                .subsequentIpAccess(null)
                .travelFromCurrentGeoSuspicious(false);

        if (previousGeoLocation.isPresent()) {
            PrecedingIpAccess precedingIpAccess = previousGeoLocation.get();
            if (precedingIpAccess.getSpeed() > THRESHOLD_VELOCITY)
                userResponseBuilder.travelToCurrentGeoSuspicious(true);
            else userResponseBuilder.travelToCurrentGeoSuspicious(false);
            userResponseBuilder.precedingIpAccess(precedingIpAccess);
        } else userResponseBuilder.travelToCurrentGeoSuspicious(false);

        if (subsequentGeoLocation.isPresent()) {
            SubsequentIpAccess subsequentIpAccess = subsequentGeoLocation.get();
            if (subsequentIpAccess.getSpeed() > THRESHOLD_VELOCITY)
                userResponseBuilder.travelFromCurrentGeoSuspicious(true);
            else userResponseBuilder.travelFromCurrentGeoSuspicious(false);
            userResponseBuilder.subsequentIpAccess(subsequentIpAccess);
        } else userResponseBuilder.travelFromCurrentGeoSuspicious(false);

        return userResponseBuilder.build();
    }

    /**
     * Computes and return the previous geo location details if present
     * @param userRequest current user request
     * @param geoLocation current geo location details
     * @return
     */
    public Optional<PrecedingIpAccess> getPreviousGeoLocation(UserRequest userRequest, GeoLocation geoLocation) {
        List<UserRequestDAO> previousRequests = userService
                .getPreviousRequest(userRequest.getUserName(), userRequest.getEventTS());

        if (previousRequests.size() == 0)
            return Optional.empty();
        UserRequestDAO previousRequest = previousRequests.get(0);

        var previousGeoLocation = new GeoLocation(previousRequest.getLatitude(), previousRequest.getLongitude(),
                previousRequest.getRadius());
        int velocity = getVelocity(userRequest, geoLocation, previousRequest, previousGeoLocation);

        PrecedingIpAccess precedingIpAccess = new PrecedingIpAccess(previousRequest.getLatitude(), previousRequest.getLongitude(),
                previousRequest.getRadius(), velocity, previousRequest.getIp(), previousRequest.getTimestamp());
        return Optional.of(precedingIpAccess);
    }

    /**
     * Computes and return the subsequent geo location if present
     * @param userRequest
     * @param geoLocation
     * @return
     */
    public Optional<SubsequentIpAccess> getSubsequentGeoLocation(UserRequest userRequest, GeoLocation geoLocation) {
        List<UserRequestDAO> subsequentRequests = userService
                .getNextRequest(userRequest.getUserName(), userRequest.getEventTS());

        if (subsequentRequests.size() == 0){
            return Optional.empty();
        }

        UserRequestDAO subsequentRequest = subsequentRequests.get(0);

        var subsequentGeoLocation = new GeoLocation(subsequentRequest.getLatitude(), subsequentRequest.getLongitude(),
                subsequentRequest.getRadius());
        int velocity = getVelocity(userRequest, geoLocation, subsequentRequest, subsequentGeoLocation);

        SubsequentIpAccess subsequentIpAccess = new SubsequentIpAccess(subsequentRequest.getLatitude(), subsequentRequest.getLongitude(),
                subsequentRequest.getRadius(), velocity, subsequentRequest.getIp(), subsequentRequest.getTimestamp());
        return Optional.of(subsequentIpAccess);
    }

    /**
     * Given geo locations of two points, it will compute the velocity
     * @param userRequest user request details
     * @param geoLocation current geo location
     * @param adjacentReq adjacent user request details
     * @param adjRequestGeoLoc adjacent geo location
     * @return the velocity of two points or -1
     */
    public int getVelocity(UserRequest userRequest, GeoLocation geoLocation, UserRequestDAO adjacentReq, GeoLocation adjRequestGeoLoc) {
        double distance = Distance.getHaversineDistance(geoLocation, adjRequestGeoLoc);
        long time = Math.abs(userRequest.getEventTS() - adjacentReq.getTimestamp());

        int velocity = 0;
        // if multiple request comes at same time
        if (time == 0) {
            velocity = -1;
        } else {
            velocity = (int) (distance / time);
        }
        return velocity;
    }

    public void printAllUsers() {
        List<UserRequestDAO> users = userService.getAllUsers();
        System.out.println("Printing all user details.....");
        users.forEach(user -> System.out.println(user));
        System.out.println("Printing all user details finished.....");
    }

}
